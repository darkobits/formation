<div class="Main__section">

  <div class="Main__logo">
<!--     <svg ng-show="::vm.logoHref">
      <use xlink:href="{{::vm.logoHref }}"></use>
    </svg> -->
    Formation
  </div>

  <p class="Main__copy">
    Formation is a form framework for Angular 1.5+. It aims to address many of
    the shortcomings in the built-in form facilities, and increase consistensy
    across large code bases by reducing the amount of boilterplace needed to
    build robust forms. It is inspired by the two leading paradigms for working
    with forms in Angular 2, <a href="//toddmotto.com/angular-2-forms-template-driven">
    template-driven forms</a> and <a href="//toddmotto.com/angular-2-forms-reactive">
    reactive forms</a>, both of which have their own advantages and drawbacks.
  </p>

  <p class="Main__copy">
    Formation consists of several small components designed to be used as
    atoms (see: <a href="//bradfrost.com/blog/post/atomic-web-design/#atoms">
    atomic web design</a>) to compose larger elements. It is completely
    unopinionated about style, and ships with no CSS or themes.
  </p>

  <h2>Template-Driven vs. Reactive</h2>

  <p class="Main__copy">
    Template-driven forms have been the longstanding paradigm in Angular 1.x.
    Structure, configuration, and validation of form controls is accomplished
    via markup and adding attributes to control elements for additional
    behavior (ex: <span class="code">required</span>, or custom directives).
    This approach is simple, and allows newcomes to Angular to create simple to
    modestly complex forms quickly, but in large applications that require
    consistency and robust validation, working with a multitude of directives
    and managing model values, state, and errors for each control can
    quickly become burdensome.
  </p>

  <p class="Main__copy">
    With reactive forms, Angular 2 encourages developers to configure forms
    declaratively in code, requiring far less markup. However, the APIs can be
    cumbersome and rely too heavily on the relationships created between various
    class instances.
  </p>

  <p class="Main__copy">
    Formation attempts to strike a balance between both approaches: eliminate
    extraneous markup and give developers a way to configure controls from code
    with Plain Old JavaScript Objects. By moving configuration from the template
    to the controller, it promotes code re-use, consistency, and maintainability.
  </p>

  <h2>Feature Overview</h2>

  <ul class="Main__list">
    <li>
      Controls are configured using Plain Old JavaScript Objects at either the
      control level or the from level. Developers no longer need to spin-up new
      directives to provide custom behavior or validation to a control.
      Configuration definitions can be shared across the application, improving
      consistency.
    </li>
    <li>
      Developers no longer need to manage two sets of state with respect to
      controls and their models (ex: a form control at
      <span class="code">vm.myForm.name</span> and its model value at
      <span class="code">vm.name</span>). The form manages model values, which
      are determined by its registered controls.
    </li>
    <li>
      Submit handlers no longer need to check the <span class="code">$valid</span>
      state of the form, wait for <span class="code">$asyncValidators</span> to
      complete, or ensure that another submission is not already in progress. A
      form's submit handler will only be invoked when it should be, and will be
      passed the model values of all controls in the form.
    </li>
    <li>
      Using <span class="code">ngMessages</span> for client-side validation has
      been greatly simplified: Errors are defined as a simple array in code, and
      one line of markup in templates. Sharing error messages across forms no
      longer requres exposing error copy to templates via controllers. Formation
      also supports assigning custom error messages on each control -- from your
      API, for example.
    </li>
    <li>
      Configuring when to display validation errors is trivial. Either set the
      behavior application-wide or for each form by providing a list of states
      (ex: <span class="code">"touched, submitted"</span>) to match against.
      Errors for a given control will be shown if either the control or the form
      has one of the states.
    </li>
    <li>
      Reset all controls to a pristine, untouched state and optionally reset the
      form's model to an initial state.
    </li>
    <li>
      Accessibility: <span class="code">id</span> and <span class="code">for</span> attributes are managed
      by the form, so controls and labels are correctly associated without any
      extra markup.
    </li>
  </ul>

  <h2>Example</h2>

  <p class="Main__copy">
    Let's take a look at how to create a form using Formation. Keep in mind that
    Formation does not come bundled with any styles, and class attributes have
    been omitted here for simplicity.
  </p>

  <p class="Main__copy">
    Here's the template strucutre you might use to construct a simple address
    form:
  </p>
</div>

<div class="Main__codeBlock">
  <highlight lang="{{::vm.codeBlocks.addressTemplate.lang }}">
    {{::vm.codeBlocks.addressTemplate.content }}
  </highlight>
</div>

<div class="Main__section">
  <p class="Main__copy">
    Notice there are no references to <span class="code">ngModel</span> on our
    controls, nor are they cluttered with attribute directives for validation.
    <span class="code">ngMessages</span> are handled with a single component,
    and all of our markup is concise and semantic.
  </p>

  <p class="Main__copy">
    Before we move to the controller, lets go over everything thats happening,
    starting with the <span class="code">form</span> element:
  </p>

  <ul class="Main__list">
    <li>
      <span class="code">name</span>: This will assign a reference to the
      Formation controller to the provided name under the current scope, just
      like Angular's form directive. The form's name is also used to construct
      the <code>id</code> attributes assigned to each control. However, it is
      entirely optional.
    </li>
    <li>
      <span class="code">controls</span>: Formation will use this object to
      configure controls. More on this below.
    </li>
    <li>
      <span class="code">show-errors-on</span>: This attribute can be a string
      of comma/space delimited flags that correspond to the state flags on an
      <span class="code">ngModel</span> controller instance or form controller.
      Formation will check each provided flag first on the control's
      <span class="code">ngModel</span> instance and then the form controller
      instance. If either have the flag and its current value is truthy (and the
      control is invalid) errors will be shown for the control. In this case, we
      are indicating that we want to show errors on invalid controls if they
      have been touched (the user has focused it and then blurred it) or if the
      user has tried to submit the
      form.
    </li>
    <li>
      <span class="code">on-submit</span>: When the form is submiteed, Formation
      will ensure there are no pending async validators, ensure the form is
      valid, then invoke the provided function, passing it an object containing
      the current model value of each control in the form.
    </li>
  </ul>

  <p class="Main__copy">
    Control elements are designed to be as simple as possible, requiring only a
    <span class="code">name</span> attribute. Error components use a
    <span class="code">for</span> attribute to indicate which control to show
    errors for. Under the hood, Formation assigngs unique <span class="code">id</span>
    attributes to controls and ensures labels and error elements are correctly
    linked to them.
  </p>

  <p class="Main__copy">
    Everything else is configured via the form's parent controller. Let's take a
    look at that now:
  </p>
</div>

<div class="Main__codeBlock">
  <highlight lang="{{::vm.codeBlocks.addressController.lang }}">
    {{::vm.codeBlocks.addressController.content }}
  </highlight>
</div>

<div class="Main__section">
  <p class="Main__copy">
    Wowza! We kept our template focused on structure, and our controller neatly
    describes exactly how each control in the form should behave. Let's go over
    each property that can be supplied to a control's configuration object:
  </p>

  <ul class="Main__list">
    <li>
      <span class="code">parsers</span> <span class="code">(Array)</span>:
      Pipeline of functions that will be called, in order, to transform updated
      view values into model values.
    </li>
    <li>
      <span class="code">formatters</span> <span class="code">(Array)</span>:
      Pipeline of functions that will be called, in order, to transform updated
      model values into view values.
    </li>
    <li>
      <span class="code">validators</span> <span class="code">(Object)</span>:
      Map of validation error keys to validation functions.
    </li>
    <li>
      <span class="code">asyncValidators</span> <span class="code">(Object)</span>:
      Map of validation error keys to asynchronous validation functions.
    </li>
    <li>
      <span class="code">ngModelOptions</span> <span class="code">(Object)</span>:
      Additional configuration for the <span class="code">ngModel</span> instance.
    </li>
    <li>
      <span class="code">errors</span> <span class="code">(Array)</span>: Ranked
      list of paired validation keys and errror messages. This will be used with
      <span class="code">ngMessages</span> to drive the errors component.
    </li>
  </ul>

  <p class="Main__copy">
    For more context about these concepts, see the official documentation for
    <a href="//docs.angularjs.org/api/ng/type/ngModel.NgModelController">ngModel</a>
    and <a href="//docs.angularjs.org/api/ngMessages/directive/ngMessages">ngMessages</a>.
    Let's take a look at a live demo of what the above form might look like
    (styles and reset button added separately, for convenience):
  </p>

  <figure class="Main__figure" style="display: flex; justify-content: center;">
    <address-form-demo></address-form-demo>
  </figure>
</div>





<!--
<div class="Main__section">

  <fm-form name="vm.myForm"
    controls="vm.controls"
    show-errors-on="touched, submitted"
    on-submit="vm.onSubmit"
    debug>

    <section class="ApiErrors">
      <fm-input name="apiErrors" type="hidden"></x-input>
      <fm-errors for="apiErrors"></x-errors>
    </section>

    <email-control name="email"></email-control>

    <email-control name="emailMatch">EMAIL (Again):</email-control>

    <section>
      <fm-textarea name="message"
        ng-disabled="vm.disabled"
        placeholder="Hello!">
        Enter your message:
      </x-textarea>
      <fm-errors class="Demo__errors" for="message"></x-errors>
    </section>

    <section>
      <fm-input name="foo"
        type="radio"
        ng-value="true"
        ng-if="!vm.toggleInput">
        true
      </x-input>

      <fm-input name="foo"
        type="radio"
        ng-value="false"
        ng-if="true">
        false
      </x-input>

      <fm-errors for="foo"></x-errors>
    </section>

    <section>
      <fm-input name="blah"
        type="checkbox"
        ng-disabled="vm.disabled">
        Do you want to receive daily marketing messages from us?
      </x-input>
      <fm-errors for="blah"></x-errors>
    </section>

    <section>
      <fm-select name="state"
        options="state.value as state.label for state in vm.states"
        placeholder="Please select a state"
        ng-disabled="vm.disabled">
        Select a state:
      </x-select>
      <fm-errors for="state"></x-errors>
    </section>

    <section>
      <button type="submit"
        ng-disabled="vm.shouldBlockSubmit()">
        Submit
      </button>
      <button type="button"
        ng-click="vm.resetForm()">
        Reset
      </button>
    </section>
  </x-form>

  <section>
    Disable: <input type="checkbox" ng-model="vm.disabled"><br>
    Remove controls: <input type="checkbox" ng-model="vm.toggleInput"><br>
    <br>
    <button ng-click="vm.debug()">Debug Scope</button>
  </section>

</div>
 -->
